<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>设计模式 - 赵绪浪</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="ZhaoXuLang" />
  <meta name="description" content="大话设计模式 第一章节 工厂模式 1.面向对象的好处？ 2.UML图 3.简述简单工厂模式 &amp;emsp;&amp;emsp;假如我们需要写一个加减乘除的计算器程" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.50" />


<link rel="canonical" href="/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="设计模式" />
<meta property="og:description" content="大话设计模式 第一章节 工厂模式 1.面向对象的好处？ 2.UML图 3.简述简单工厂模式 &emsp;&emsp;假如我们需要写一个加减乘除的计算器程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" /><meta property="article:published_time" content="2018-11-05T18:05:24&#43;08:00"/>
<meta property="article:modified_time" content="2018-11-05T18:05:24&#43;08:00"/>

<meta itemprop="name" content="设计模式">
<meta itemprop="description" content="大话设计模式 第一章节 工厂模式 1.面向对象的好处？ 2.UML图 3.简述简单工厂模式 &emsp;&emsp;假如我们需要写一个加减乘除的计算器程">


<meta itemprop="datePublished" content="2018-11-05T18:05:24&#43;08:00" />
<meta itemprop="dateModified" content="2018-11-05T18:05:24&#43;08:00" />
<meta itemprop="wordCount" content="3073">



<meta itemprop="keywords" content="设计模式," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="设计模式"/>
<meta name="twitter:description" content="大话设计模式 第一章节 工厂模式 1.面向对象的好处？ 2.UML图 3.简述简单工厂模式 &emsp;&emsp;假如我们需要写一个加减乘除的计算器程"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">ZhaoXuLang</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">ZhaoXuLang</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">设计模式</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-11-05 </span>
        <div class="post-category">
            
              <a href="/categories/%E5%AD%A6%E4%B9%A0/"> 学习 </a>
            
              <a href="/categories/%E7%BC%96%E7%A8%8B/"> 编程 </a>
            
          </div>
        <span class="more-meta"> 约 3073 字 </span>
        <span class="more-meta"> 预计阅读 7 分钟 </span>
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#大话设计模式">大话设计模式</a>
<ul>
<li><a href="#第一章节-工厂模式">第一章节   工厂模式</a>
<ul>
<li><a href="#1-面向对象的好处">1.面向对象的好处？</a></li>
<li><a href="#2-uml图">2.UML图</a></li>
<li><a href="#3-简述简单工厂模式">3.简述简单工厂模式</a></li>
</ul></li>
<li><a href="#第二章节-策略模式">第二章节  策略模式</a>
<ul>
<li><a href="#1-商场促销问题">1.商场促销问题</a></li>
<li><a href="#2-策略模式与简单工厂模式的区别">2.策略模式与简单工厂模式的区别？</a></li>
<li><a href="#3-策略模式的应用">3.策略模式的应用</a></li>
</ul></li>
<li><a href="#第三章节-单一职责原则">第三章节  单一职责原则</a></li>
<li><a href="#第四章节-开放-封闭原则-ocp原则">第四章节 开放-封闭原则  OCP原则</a></li>
<li><a href="#第五章节-依赖倒转原则">第五章节 依赖倒转原则</a></li>
<li><a href="#第六章-装饰模式-模糊">第六章 装饰模式 <em>模糊</em></a></li>
<li><a href="#第七章-代理模式">第七章 代理模式</a></li>
<li><a href="#第八章-工厂方法模式">第八章 工厂方法模式</a>
<ul>
<li><a href="#基本概念">基本概念</a></li>
</ul></li>
<li><a href="#第九章-原型模式">第九章 原型模式</a>
<ul>
<li><a href="#基本概念-1">基本概念</a></li>
<li><a href="#基本概念-2">基本概念</a></li>
</ul></li>
<li><a href="#十一章-迪米特法则">十一章 迪米特法则</a>
<ul>
<li><a href="#基本概念-3">基本概念</a></li>
</ul></li>
<li><a href="#第十二章-外观模式">第十二章 外观模式</a>
<ul>
<li><a href="#基本概念-4">基本概念</a></li>
<li><a href="#应用场景">应用场景</a></li>
</ul></li>
<li><a href="#第十三章-建造者模式">第十三章 建造者模式</a>
<ul>
<li><a href="#基本概念-5">基本概念</a></li>
<li><a href="#应用场景-1">应用场景</a></li>
</ul></li>
<li><a href="#第十四章-观察者模式">第十四章 观察者模式</a>
<ul>
<li><a href="#基本概念-6">基本概念</a></li>
<li><a href="#应用场景-2">应用场景</a></li>
</ul></li>
<li><a href="#抽象工厂模式">抽象工厂模式</a>
<ul>
<li><a href="#基本概念-7">基本概念</a></li>
<li><a href="#应用场景-3">应用场景</a></li>
</ul></li>
<li><a href="#第十六章节-状态模式">第十六章节 状态模式</a>
<ul>
<li><a href="#基本概念-8">基本概念</a></li>
<li><a href="#应用场景-4">应用场景</a></li>
</ul></li>
<li><a href="#第十七章-适配器模式">第十七章 适配器模式</a>
<ul>
<li><a href="#基本概念-9">基本概念</a></li>
<li><a href="#应用场景-5">应用场景</a></li>
</ul></li>
<li><a href="#第十八章-备忘录模式">第十八章 备忘录模式</a></li>
<li><a href="#基本概念-10">基本概念</a></li>
<li><a href="#应用场景-6">应用场景</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h1 id="大话设计模式">大话设计模式</h1>

<h2 id="第一章节-工厂模式">第一章节   工厂模式</h2>

<h3 id="1-面向对象的好处">1.面向对象的好处？</h3>

<h3 id="2-uml图">2.UML图</h3>

<h3 id="3-简述简单工厂模式">3.简述简单工厂模式</h3>

<p>&emsp;&emsp;假如我们需要写一个加减乘除的计算器程序，如果使用面向过程的思维来解决这个问题，一旦我们修改了其中某些需求（比如增加开根号的运算），那么我们就会关于运算部分的代码，这对于一些系统来说是很有风险的操作。也不符合面向对象的封装的方法。
&emsp;&emsp;我们可以把界面和运算进行分层出来，界面类处理界面的事情，运算类只处理运算逻辑。这样是非常可以扩展的，如果我们需要增加一种运算，我们只需要多写一个运算类继承运算基类。
&emsp;&emsp;如何让计算机知道你将要使用哪个运算类呢？及对象的实例化问题，到底要实例化谁，未来会不会增加实例化对象，这些很容易变化的部分。我们可以使用一个单独的类来做这个创造实例的过程，这就是工厂。<br />
<em>编程是一门技术，更加是一门艺术</em></p>

<h2 id="第二章节-策略模式">第二章节  策略模式</h2>

<h3 id="1-商场促销问题">1.商场促销问题</h3>

<p>&emsp;&emsp;比如商场打不同的折扣,双十一打五折，公司周年庆打四折，每周五打八折。商场不仅仅有打折问题，还有 满多少返现多少，比如满300返现100。商场积分问题，100块可以积10分。这一系列的问题，都应考虑到，不可能每次都要去修改代码后重新编译部署。这就是一个策略问题。
&emsp;&emsp;对于打折问题，以前学过简单工厂，我们可以写一个基类，然后打不同的折扣去继承这个基类，这样写不符合面向对象封装的方法。不管打多少折都是打折，没必要写那么多的类。
2.策略模式<br />
&emsp;&emsp;<em>策略模式</em>:它定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。
策略模式是封装算法的，需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性，比如超市各种方式的促销活动。<br />
引入反射</p>

<h3 id="2-策略模式与简单工厂模式的区别">2.策略模式与简单工厂模式的区别？</h3>

<h3 id="3-策略模式的应用">3.策略模式的应用</h3>

<h2 id="第三章节-单一职责原则">第三章节  单一职责原则</h2>

<p><em>就一个类而言，应该仅有一个引起它变化的原因</em><br />
&emsp;&emsp;如果一个类承担的职责过多，就等于把这些职责偶合在一起，一个职责的变化可能会削弱或抑制这个类完成其它职责的能力。<br />
再设计一个俄罗斯方块游戏的时候，我们可以把界面和逻辑分开来进行设计，一般界面是很容易进行改变的，但是逻辑一般都不会进行改变。PC上的俄罗斯方块，我们可以通过更改界面类把它给移植到Android端。如果把全部都给蹂躏在一堆，那还得进行全部的修改，将会耗费更大的开销。只干一件事，总比什么事都干要好。相机用来拍照，mp3用来听歌，这些都是他们的单一职责。</p>

<h2 id="第四章节-开放-封闭原则-ocp原则">第四章节 开放-封闭原则  OCP原则</h2>

<p>&emsp;&emsp;*开放封闭原则，是说软件实体应该可以扩展，但是不可以修改*。  其实可以这样理解，对于扩展是开放的，对于修改则是封闭的。最初编写代码的时候，假设变化不会发生，但当变化发生时候，我们就创建抽象来隔离以后发生的同类的变化。面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。此乃开放封闭原则的精神所在。<br />
&emsp;&emsp;开发者应该仅对程序中呈现出频繁变化的那部分进行抽象，而不是时时刻刻的对每个部分进行同样的抽象，及拒绝不成熟的抽象和抽象本身一样的重要。</p>

<h2 id="第五章节-依赖倒转原则">第五章节 依赖倒转原则</h2>

<p>&emsp;&emsp;*抽象不应该依赖细节，细节应该依赖于抽象*。意为要针对接口编程，不要对实现编程。<br />
&emsp;&emsp;依赖倒转原则：<br />
&gt;高层模块不应该依赖底层模块，都应该依赖于抽象。
&gt;抽象不应该依赖细节，细节应该依赖抽象。</p>

<p>里氏代换原则：简单来说子类型必须能够替换掉他们的父类型。依赖倒转是面向对象的标志，不管使用哪种编程语言吗，编写时考虑的都是如何针对抽象编程而非细节编程，及所有的依赖关系都是终止于抽象类或接口，这就是面向对象的设计。</p>

<h2 id="第六章-装饰模式-模糊">第六章 装饰模式 <em>模糊</em></h2>

<p>&emsp;&emsp;*装饰模式*，动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p>

<h2 id="第七章-代理模式">第七章 代理模式</h2>

<h2 id="第八章-工厂方法模式">第八章 工厂方法模式</h2>

<h3 id="基本概念">基本概念</h3>

<p><em>工厂方法模式</em> 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。</p>

<h2 id="第九章-原型模式">第九章 原型模式</h2>

<h3 id="基本概念-1">基本概念</h3>

<p>*原型模式*用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
&emsp;&emsp;它其实不用重新的初始化对象，而是动态的获得对象运行时的状态。<br />
##第十章 模板方法模式<br />
&emsp;&emsp;当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。</p>

<h3 id="基本概念-2">基本概念</h3>

<p><em>模板方法模式</em> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>

<h2 id="十一章-迪米特法则">十一章 迪米特法则</h2>

<h3 id="基本概念-3">基本概念</h3>

<p>*迪米特法则*，也叫最少知识原则。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p>

<h2 id="第十二章-外观模式">第十二章 外观模式</h2>

<h3 id="基本概念-4">基本概念</h3>

<p>*外观模式*为子系统中的一组接口体统一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>

<h3 id="应用场景">应用场景</h3>

<p>比如当有一个功能很复杂或是很老旧难以维护的系统时候， 我们可以为新系统开发一个外观Facade类，来提供设计对那些复杂功能的接口，新系统与Facade进行交互，Facade来进行与老旧系统的交互复杂的工作。</p>

<h2 id="第十三章-建造者模式">第十三章 建造者模式</h2>

<h3 id="基本概念-5">基本概念</h3>

<p>*建造者模式*将一个复杂对象的构建与它的表示分离，使得同样的建造过程可以创建不同的表示。</p>

<h3 id="应用场景-1">应用场景</h3>

<p>建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。</p>

<h2 id="第十四章-观察者模式">第十四章 观察者模式</h2>

<h3 id="基本概念-6">基本概念</h3>

<p>*观察者模式*定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知 所有观察者对象，使它们能够自动更新自己。<br />
*事件委托*，委托是一种引用方法的类型，一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值，委托可以看作是对函数的抽象，是函数的类，委托的实例将代表一个具体的函数。</p>

<h3 id="应用场景-2">应用场景</h3>

<p>当一个对象的改变需要同时改变其它对象的时候。观察者模式所做的工作其实就是在解除耦合，让耦合的双方都依赖于抽象，而不是依赖于具体，从而使得各自的变化都不影响另一边的变化。</p>

<h2 id="抽象工厂模式">抽象工厂模式</h2>

<h3 id="基本概念-7">基本概念</h3>

<p>*抽象工厂模式*，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br />
<em>反射</em><br />
<em>依赖注入</em></p>

<h3 id="应用场景-3">应用场景</h3>

<h2 id="第十六章节-状态模式">第十六章节 状态模式</h2>

<h3 id="基本概念-8">基本概念</h3>

<p><strong>状态模式</strong>，当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。<br />
状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂的情况，把状态的判断逻辑转移到表示不同状态的一些列类当中，可以把复杂的判断逻辑简化。</p>

<h3 id="应用场景-4">应用场景</h3>

<p>当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。</p>

<h2 id="第十七章-适配器模式">第十七章 适配器模式</h2>

<h3 id="基本概念-9">基本概念</h3>

<p><strong>适配器模式</strong>,将一个类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br />
- 类适配器
- 对象适配器</p>

<h3 id="应用场景-5">应用场景</h3>

<p>双方都不愿意修改时使用适配器适配。</p>

<h2 id="第十八章-备忘录模式">第十八章 备忘录模式</h2>

<h2 id="基本概念-10">基本概念</h2>

<p><strong>备忘录</strong>，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。</p>

<h2 id="应用场景-6">应用场景</h2>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">ZhaoXuLang</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2018-11-05</span>
  </p>
  
  
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          
        </div>

      
      <nav class="post-nav">
        
        
          <a class="next" href="/post/studygit/">
            <span class="next-text nav-default">git版本管理工具 </span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:zhaxulang@qq.com" class="iconfont icon-email" title="email"></a>
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">ZhaoXuLang</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>








</body>
</html>
